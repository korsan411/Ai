// ===============================================================
// ğŸ§  CncAi â€” Laser G-code Generator (Improvements v1)
// ÙŠØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø£ØµÙ„ÙŠ Ù…Ø¹: Header/FooterØŒ precision, laser on/off, home, M84
// ===============================================================

/**
 * Helper: format number with precision
 */
function fmt(n, p = 3) {
  return Number(n).toFixed(p);
}

/**
 * generateLaserEngraveGcode
 * - ÙŠØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ù…Ù†Ø·Ù‚ Ø§Ù„Ù…Ø³Ø­ Ø§Ù„Ù†Ù‚Ø·ÙŠ (raster-like engraving)
 * - ÙŠØ¯Ø¹Ù… power Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ (dynamicPower)
 * - ÙŠØ¶ÙŠÙ Header/Footer ÙˆØ¢Ù„ÙŠØ§Øª Ø£Ù…Ø§Ù† (return home, disable motors)
 */
function generateLaserEngraveGcode() {
  if (!grayMat || !contour) {
    throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©");
  }

  try {
    InputValidator.validateLaserSettings();

    const laserPower = parseInt(document.getElementById('laserPower').value) || 80;
    const laserSpeed = parseInt(document.getElementById('laserSpeed').value) || 2000;
    const dynamicPower = document.getElementById('laserDynamic').checked;

    const workWidth = cmToMm(parseFloat(document.getElementById('laserWorkWidth').value) || 30);
    const workHeight = cmToMm(parseFloat(document.getElementById('laserWorkHeight').value) || 20);
    const originX = cmToMm(parseFloat(document.getElementById('laserOriginX').value) || 0);
    const originY = cmToMm(parseFloat(document.getElementById('laserOriginY').value) || 0);

    const lines = [];
    const precision = 3;

    // Header
    lines.push('; ============================================================');
    lines.push('; ğŸ§  Generated by CncAi â€” Laser Engrave');
    lines.push('; Mode: Laser | Pattern: Engrave (Raster-like)');
    lines.push('; Date: ' + new Date().toLocaleString());
    lines.push('; Work: ' + workWidth + 'x' + workHeight + ' mm');
    lines.push('; Safe: using home & motors control');
    lines.push('; ============================================================');
    lines.push('G90'); // absolute
    lines.push('G21'); // mm
    lines.push('G17'); // XY plane
    lines.push('G28'); // go home first (optional safety)
    lines.push('G0 Z0'); // ensure Z plane (laser usually 2D)
    // Default laser on with base power (controller may require M3 Sxxx)
    lines.push('M3 S' + Math.round(laserPower * 10)); // keep existing scaling approach
    lines.push('; --- Begin laser engraving ---');

    const scaleX = workWidth / previewCanvas.width;
    const scaleY = workHeight / previewCanvas.height;

    const stepOver = 3.0;
    let totalLen = 0;
    let pointCount = 0;
    let lastPower = null; // for dynamic power changes optimization

    for (let y = 0; y < previewCanvas.height; y += stepOver) {
      const rowPoints = [];

      for (let x = 0; x < previewCanvas.width; x += 3) {
        const pt = new cv.Point(x, y);
        const inside = cv.pointPolygonTest(contour, pt, false) >= 0;

        if (inside) {
          const pv = sampleGrayAt(x, y);
          const power = dynamicPower ? Math.round((pv / 255) * laserPower) : laserPower;
          const scaledX = (x * scaleX) + originX;
          const scaledY = (y * scaleY) + originY;
          rowPoints.push({ x: scaledX, y: scaledY, power });
          pointCount++;

          // safety cap to avoid extreme long files
          if (pointCount > 20000) break;
        }
      }

      if (rowPoints.length > 1) {
        const reverse = (y / stepOver) % 2 !== 0;
        if (reverse) rowPoints.reverse();

        // move to start of row
        lines.push('G0 X' + fmt(rowPoints[0].x, precision) + ' Y' + fmt(rowPoints[0].y, precision));
        // set feed
        lines.push('G1 F' + Math.round(laserSpeed));

        // If dynamic power: set M3 S before row or on power change
        lastPower = null;
        for (let i = 0; i < rowPoints.length; i++) {
          const p = rowPoints[i];
          // if dynamicPower and power changes, set new S (scaled same as above)
          if (dynamicPower) {
            const sVal = Math.round(p.power * 10);
            if (lastPower !== sVal) {
              lines.push('M3 S' + sVal); // update laser power
              lastPower = sVal;
            }
          }
          lines.push('G1 X' + fmt(p.x, precision) + ' Y' + fmt(p.y, precision));
        }

        totalLen += calculateRowLength(rowPoints);
      }

      if (pointCount > 20000) {
        console.warn('Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø¨ÙƒØ±Ø© Ø¨Ø³Ø¨Ø¨ Ø­Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· (20000)');
        break;
      }
    }

    // Footer: turn off laser, move home, disable motors
    lines.push('; --- End of laser engraving ---');
    lines.push('M5 ; laser off');
    lines.push('G0 X0 Y0 ; return to home');
    lines.push('M84 ; disable motors');
    lines.push('M30 ; program end');
    lines.push('; âœ… G-code generation completed successfully by CncAi');
    lines.push('; ============================================================');

    const timeMin = (totalLen / (laserSpeed || 1)) || 0;
    const estNode = document.getElementById('estTime');
    if (estNode) estNode.innerHTML = "â±ï¸ ØªÙ‚Ø¯ÙŠØ± ÙˆÙ‚Øª Ø§Ù„Ù„ÙŠØ²Ø±: " + timeMin.toFixed(1) + " Ø¯Ù‚ÙŠÙ‚Ø© | " + pointCount + " Ù†Ù‚Ø·Ø©";

    return lines.join('\n');
  } catch (error) {
    console.error('Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠØ²Ø±:', error);
    throw new Error('ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠØ²Ø±: ' + error.message);
  }
}

/**
 * generateLaserQuickGcode
 * - Ù†Ø³Ø®Ø© Ø³Ø±ÙŠØ¹Ø© Ù„Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©ØŒ Ù…Ø¹ Header/Footer ÙˆØ¹ÙˆØ¯Ø© Home
 */
function generateLaserQuickGcode() {
  if (!grayMat || !contour) {
    throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©");
  }

  try {
    const laserPower = 80;
    const laserSpeed = 3000;

    const workWidth = cmToMm(parseFloat(document.getElementById('laserWorkWidth').value) || 30);
    const workHeight = cmToMm(parseFloat(document.getElementById('laserWorkHeight').value) || 20);
    const originX = cmToMm(parseFloat(document.getElementById('laserOriginX').value) || 0);
    const originY = cmToMm(parseFloat(document.getElementById('laserOriginY').value) || 0);

    const lines = [];
    const precision = 3;

    // Header
    lines.push('; ============================================================');
    lines.push('; ğŸ§  Generated by CncAi â€” Laser Quick Mode');
    lines.push('; Mode: Laser | Pattern: Quick');
    lines.push('; Date: ' + new Date().toLocaleString());
    lines.push('; ============================================================');
    lines.push('G90'); lines.push('G21'); lines.push('G17');
    lines.push('G28'); // home
    lines.push('M3 S' + Math.round(laserPower * 10));
    lines.push('; --- Begin quick pass ---');

    const scaleX = workWidth / previewCanvas.width;
    const scaleY = workHeight / previewCanvas.height;

    const stepOver = 5.0;
    let totalLen = 0;
    let pointCount = 0;

    for (let y = 0; y < previewCanvas.height; y += stepOver) {
      const rowPoints = [];

      for (let x = 0; x < previewCanvas.width; x += 5) {
        const pt = new cv.Point(x, y);
        const inside = cv.pointPolygonTest(contour, pt, false) >= 0;

        if (inside) {
          const scaledX = (x * scaleX) + originX;
          const scaledY = (y * scaleY) + originY;
          rowPoints.push({ x: scaledX, y: scaledY });
          pointCount++;

          if (pointCount > 5000) break;
        }
      }

      if (rowPoints.length > 1) {
        const reverse = (y / stepOver) % 2 !== 0;
        if (reverse) rowPoints.reverse();

        lines.push('G0 X' + fmt(rowPoints[0].x, precision) + ' Y' + fmt(rowPoints[0].y, precision));
        lines.push('G1 F' + Math.round(laserSpeed));

        for (let i = 0; i < rowPoints.length; i++) {
          const p = rowPoints[i];
          lines.push('G1 X' + fmt(p.x, precision) + ' Y' + fmt(p.y, precision));
        }

        totalLen += calculateRowLength(rowPoints);
      }

      if (pointCount > 5000) break;
    }

    // Footer
    lines.push('; --- End quick pass ---');
    lines.push('M5'); // laser off
    lines.push('G0 X0 Y0'); // home
    lines.push('M84');
    lines.push('M30');
    lines.push('; ============================================================');

    const estNode = document.getElementById('estTime');
    if (estNode) estNode.innerHTML = "â±ï¸ ÙˆØ¶Ø¹ Ø³Ø±ÙŠØ¹: " + pointCount + " Ù†Ù‚Ø·Ø©";

    return lines.join('\n');
  } catch (error) {
    console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø³Ø±ÙŠØ¹ Ù„Ù„Ù„ÙŠØ²Ø±:', error);
    throw new Error('ÙØ´Ù„ ÙÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø³Ø±ÙŠØ¹: ' + error.message);
  }
}

/**
 * generateLaserCutGcode
 * - ÙŠØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ù…Ù†Ø·Ù‚ Ø§Ù„ÙƒÙ†ØªÙˆØ± Ù„Ù„Ù‚Øµ
 * - ÙŠØ¯Ø¹Ù… airAssist (M8/M9)
 * - ÙŠØ¶ÙŠÙ Header/Footer ÙˆØ¹ÙˆØ¯Ø© HomeØŒ Ø¥Ø·ÙØ§Ø¡ Ø§Ù„Ù„ÙŠØ²Ø±ØŒ ÙˆØ¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø­Ø±ÙƒØ§Øª
 */
function generateLaserCutGcode() {
  if (!grayMat || !contour) {
    throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø­ÙˆØ§Ù Ù„ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ù‚Øµ");
  }

  try {
    InputValidator.validateLaserSettings();

    const laserPower = parseInt(document.getElementById('laserPower').value) || 80;
    const laserSpeed = parseInt(document.getElementById('laserSpeed').value) || 1000;
    const laserPasses = parseInt(document.getElementById('laserPasses').value) || 1;
    const airAssist = document.getElementById('laserAirAssist').checked;

    const workWidth = cmToMm(parseFloat(document.getElementById('laserWorkWidth').value) || 30);
    const workHeight = cmToMm(parseFloat(document.getElementById('laserWorkHeight').value) || 20);
    const originX = cmToMm(parseFloat(document.getElementById('laserOriginX').value) || 0);
    const originY = cmToMm(parseFloat(document.getElementById('laserOriginY').value) || 0);
    const scaleX = workWidth / previewCanvas.width;
    const scaleY = workHeight / previewCanvas.height;

    const lines = [];
    const precision = 3;

    // Header
    lines.push('; ============================================================');
    lines.push('; ğŸ§  Generated by CncAi â€” Laser Cut');
    lines.push('; Mode: Laser | Pattern: Cut (Contour)');
    lines.push('; Date: ' + new Date().toLocaleString());
    lines.push('; Passes: ' + laserPasses + ' | AirAssist: ' + (airAssist ? 'ON' : 'OFF'));
    lines.push('; ============================================================');
    lines.push('G90'); lines.push('G21'); lines.push('G17');
    lines.push('G28'); // home
    if (airAssist) lines.push('M8'); // air assist on
    lines.push('; --- Begin cutting passes ---');

    const contoursToUse = [contour, ...additionalContours.map(c => c.contour)].filter(c => c);
    let totalLen = 0;

    for (let pass = 0; pass < laserPasses; pass++) {
      for (const cnt of contoursToUse) {
        const data = cnt.data32S;
        if (!data || data.length < 4) continue;

        let x0 = data[0], y0 = data[1];
        const startX = (x0 * scaleX + originX).toFixed(precision);
        const startY = (y0 * scaleY + originY).toFixed(precision);

        lines.push(`G0 X${startX} Y${startY}`);
        // set laser power for cut (scaled same way)
        lines.push(`M3 S${Math.round(laserPower * 10)}`);
        lines.push(`G1 F${laserSpeed.toFixed(0)}`);

        for (let i = 2; i < data.length; i += 2) {
          const x = data[i], y = data[i + 1];
          const px = (x * scaleX + originX).toFixed(precision);
          const py = (y * scaleY + originY).toFixed(precision);
          lines.push(`G1 X${px} Y${py}`);
          totalLen += Math.hypot(x - x0, y - y0);
          x0 = x; y0 = y;
        }

        lines.push(`G1 X${startX} Y${startY}`);
        lines.push('M5'); // laser off for this contour
      }
    }

    if (airAssist) lines.push('M9'); // air assist off

    // Footer: return home and disable motors
    lines.push('; --- End cutting passes ---');
    lines.push('G0 Z0');
    lines.push('G0 X0 Y0');
    lines.push('M5'); // ensure laser off
    lines.push('M84'); // disable motors
    lines.push('M30');
    lines.push('; âœ… G-code generation completed successfully by CncAi');
    lines.push('; ============================================================');

    const timeMin = totalLen / (laserSpeed || 1);
    const estNode = document.getElementById('estTime');
    if (estNode) estNode.innerHTML = "â±ï¸ ØªÙ‚Ø¯ÙŠØ± ÙˆÙ‚Øª Ø§Ù„Ù‚Øµ: " + timeMin.toFixed(1) + " Ø¯Ù‚ÙŠÙ‚Ø©";

    return lines.join('\n');

  } catch (error) {
    console.error('Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ù‚Øµ Ø§Ù„Ù„ÙŠØ²Ø±:', error);
    throw new Error('ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ù‚Øµ Ø§Ù„Ù„ÙŠØ²Ø±: ' + error.message);
  }
}
