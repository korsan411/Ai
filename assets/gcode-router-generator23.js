// ===============================================================
// ğŸ§  CncAi â€” Router G-code Generator (Raster + Contour + Combo)
// Ø§Ù„Ø¥ØµØ¯Ø§Ø± 2.5.2 â€” ØªØ­Ø¯ÙŠØ« Ù†ÙˆÙÙ…Ø¨Ø± 2025
// ===============================================================

function fmt(v, p = 3) {
  return Number(v).toFixed(p);
}

// ===============================================================
// ğŸªµ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Raster
// ===============================================================
function generateRasterGcode(scaleDown = false) {
  if (!grayMat || !contour) throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©");
  try {
    InputValidator.validateRouterSettings();

    const dir = document.getElementById('scanDir').value;
    const stepOver = parseFloat(document.getElementById('stepOver').value) || 5;
    const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
    const feed = parseFloat(document.getElementById('feedRate').value) || 800;
    const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
    const useFixedZ = document.getElementById('fixedZ').checked;
    const fixedZValue = parseFloat(document.getElementById('fixedZValue').value) || -1.0;
    const invertZ = document.getElementById('invertZ').checked;
    const workWidth = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30);
    const workHeight = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20);
    const originX = cmToMm(parseFloat(document.getElementById('originX').value) || 0);
    const originY = cmToMm(parseFloat(document.getElementById('originY').value) || 0);

    const lines = [];
    const precision = 3;
    let totalLen = 0;
    let lastZ = null;

    function moveSafeZ(targetZ) {
      if (lastZ !== targetZ) {
        lines.push(`G0 Z${fmt(targetZ)}`);
        lastZ = targetZ;
      }
    }

    // Header
    lines.push('; ============================================================');
    lines.push('; ğŸ§  Generated by CncAi â€” Router Raster Mode');
    lines.push('; Version: 2.5.2');
    lines.push('; Date: ' + new Date().toLocaleString());
    lines.push(`; SafeZ: ${safeZ} mm | Feed: ${feed} mm/min`);
    lines.push('; ============================================================');
    lines.push('G90 G21 G17');
    lines.push('G28');
    moveSafeZ(safeZ);
    lines.push('M3 ; spindle on');
    lines.push('; --- Begin Raster Pass ---');

    const step = scaleDown ? stepOver * 4 : stepOver;
    const scaleX = workWidth / previewCanvas.width;
    const scaleY = workHeight / previewCanvas.height;

    if (dir === 'x') {
      for (let y = 0; y < previewCanvas.height; y += step) {
        const rowPoints = [];
        let inContour = false, segmentStart = -1;
        for (let x = 0; x < previewCanvas.width; x += 2) {
          const pt = new cv.Point(x, y);
          const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
          if (inside && !inContour) { segmentStart = x; inContour = true; }
          else if (!inside && inContour) {
            addSegmentPoints(rowPoints, segmentStart, x - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
            inContour = false;
          }
        }
        if (inContour) addSegmentPoints(rowPoints, segmentStart, previewCanvas.width - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
        if (rowPoints.length > 1) {
          processRowPoints(rowPoints, lines, feed, safeZ, (y / step) % 2 !== 0);
          totalLen += calculateRowLength(rowPoints);
        }
      }
    } else {
      for (let x = 0; x < previewCanvas.width; x += step) {
        const colPoints = [];
        let inContour = false, segmentStart = -1;
        for (let y = 0; y < previewCanvas.height; y += 2) {
          const pt = new cv.Point(x, y);
          const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
          if (inside && !inContour) { segmentStart = y; inContour = true; }
          else if (!inside && inContour) {
            addVerticalSegmentPoints(colPoints, x, segmentStart, y - 1, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
            inContour = false;
          }
        }
        if (inContour) addVerticalSegmentPoints(colPoints, x, segmentStart, previewCanvas.height - 1, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
        if (colPoints.length > 1) {
          processRowPoints(colPoints, lines, feed, safeZ, (x / step) % 2 !== 0);
          totalLen += calculateRowLength(colPoints);
        }
      }
    }

    lines.push('; --- End Raster Pass ---');
    moveSafeZ(safeZ);
    lines.push('M5 ; stop spindle');
    lines.push('G0 X0 Y0');
    lines.push('M84');
    lines.push('M30');
    lines.push('; âœ… Completed successfully by CncAi');
    lines.push('; ============================================================');

    const timeMin = (totalLen / (feed || 1));
    const estNode = document.getElementById('estTime');
    if (estNode) estNode.innerHTML = `â±ï¸ Raster: ${timeMin.toFixed(1)} Ø¯Ù‚ÙŠÙ‚Ø©`;

    return lines.join('\n');
  } catch (error) {
    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Raster:', error);
    throw new Error('ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Raster: ' + error.message);
  }
}

// ===============================================================
// âœ‚ï¸ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Contour
// ===============================================================
function generateContourGcode() {
  if (!grayMat || !contour) throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø­ÙˆØ§Ù Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯");
  try {
    InputValidator.validateRouterSettings();

    const mode = document.getElementById('contourMode').value || 'outer';
    const feed = parseFloat(document.getElementById('feedRate').value) || 800;
    const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
    const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
    const useFixedZ = document.getElementById('fixedZ').checked;
    const fixedZValue = parseFloat(document.getElementById('fixedZValue').value) || -1.0;
    const invertZ = document.getElementById('invertZ').checked;
    const workWidth = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30);
    const workHeight = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20);
    const originX = cmToMm(parseFloat(document.getElementById('originX').value) || 0);
    const originY = cmToMm(parseFloat(document.getElementById('originY').value) || 0);
    const scaleX = workWidth / previewCanvas.width;
    const scaleY = workHeight / previewCanvas.height;

    const lines = [];
    const precision = 3;
    let totalLen = 0;

    lines.push('; ============================================================');
    lines.push('; ğŸ§  Generated by CncAi â€” Router Contour Mode');
    lines.push('; Version: 2.5.2');
    lines.push('; Date: ' + new Date().toLocaleString());
    lines.push(`; SafeZ: ${safeZ} mm | Feed: ${feed} mm/min | MaxDepth: ${maxDepth}`);
    lines.push('; ============================================================');
    lines.push('G90 G21 G17');
    lines.push('G28');
    lines.push('M3 ; spindle on');
    lines.push('G0 Z' + fmt(safeZ));
    lines.push('; --- Begin Contour Pass ---');

    const contoursToUse = (mode === 'outer') ? [contour] : [contour, ...additionalContours.map(c => c.contour)];

    for (const cnt of contoursToUse) {
      if (!cnt) continue;
      const data = cnt.data32S;
      if (!data || data.length < 4) continue;
      let x0 = data[0], y0 = data[1];
      const startX = (x0 * scaleX + originX).toFixed(precision);
      const startY = (y0 * scaleY + originY).toFixed(precision);

      const pv0 = sampleGrayAt(x0, y0);
      let zStart = useFixedZ ? fixedZValue : -((255 - pv0) / 255.0) * maxDepth;
      if (invertZ) zStart = -zStart;

      lines.push(`G0 X${startX} Y${startY} Z${fmt(safeZ)}`);
      lines.push(`G1 F${feed}`);
      lines.push(`G1 Z${fmt(zStart)}`);

      for (let i = 2; i < data.length; i += 2) {
        const x = data[i], y = data[i + 1];
        const px = (x * scaleX + originX).toFixed(precision);
        const py = (y * scaleY + originY).toFixed(precision);
        const pv = sampleGrayAt(x, y);
        let zVal = useFixedZ ? fixedZValue : -((255 - pv) / 255.0) * maxDepth;
        if (invertZ) zVal = -zVal;
        lines.push(`G1 X${px} Y${py} Z${fmt(zVal)}`);
        totalLen += Math.hypot(x - x0, y - y0);
        x0 = x; y0 = y;
      }
      lines.push(`G1 X${startX} Y${startY} Z${fmt(zStart)}`);
      lines.push(`G0 Z${fmt(safeZ)}`);
    }

    lines.push('; --- End Contour Pass ---');
    lines.push('M5');
    lines.push('G0 X0 Y0');
    lines.push('M84');
    lines.push('M30');
    lines.push('; âœ… Completed successfully by CncAi');
    lines.push('; ============================================================');

    return lines.join('\n');
  } catch (error) {
    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Contour:', error);
    throw new Error('ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Contour: ' + error.message);
  }
}

// ===============================================================
// ğŸ§  Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¯Ù…Ø¬: Contour + Raster
// ===============================================================
function generateComboGcode() {
  try {
    showToast("ğŸ”„ Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ù…Ø²Ø¯ÙˆØ¬ (Contour + Raster)...", 3000);

    const contourCode = generateContourGcode();
    const rasterCode = generateRasterGcode();

    const lines = [];
    lines.push('; ============================================================');
    lines.push('; ğŸ§  Generated by CncAi â€” Combo Mode (Contour + Raster)');
    lines.push('; Version: 2.5.2');
    lines.push('; Date: ' + new Date().toLocaleString());
    lines.push('; ============================================================');
    lines.push('; --- Begin Contour Section ---');
    lines.push(contourCode);
    lines.push('; --- End Contour Section ---');
    lines.push('; --- Begin Raster Section ---');
    lines.push(rasterCode);
    lines.push('; --- End Raster Section ---');
    lines.push('; âœ… Combo G-code completed successfully by CncAi');
    lines.push('; ============================================================');

    const finalCode = lines.join('\n');
    const estNode = document.getElementById('estTime');
    if (estNode) estNode.innerHTML = "ğŸ§® ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ù…Ø´ØªØ±Ùƒ (Contour + Raster)";

    showToast("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬ Ø¨Ù†Ø¬Ø§Ø­!", 2500);
    return finalCode;
  } catch (err) {
    console.error("âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬:", err);
    showToast("âŒ ÙØ´Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬", 4000);
    throw err;
  }
}
